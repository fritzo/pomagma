import re
import parsable
from pomagma import parser, compiler
from pomagma.compiler import (
    Variable,
    Function,
    Sequent,
    add_costs,
    )


def print_compiles(compiles):
    for cost, strategy in compiles:
        print '# cost = {0}'.format(cost)
        print re.sub(': ', '\n', repr(strategy))
        print


def measure_sequent(sequent):
    print '-' * 78
    print 'Compiling full search: {0}'.format(sequent)
    compiles = sequent.compile()
    print_compiles(compiles)
    full_cost = add_costs(*[cost for cost, _ in compiles])

    incremental_cost = None
    for event in sequent.get_events():
        print 'Compiling incremental search given: {0}'.format(event)
        compiles = sequent.compile_given(event)
        print_compiles(compiles)
        if event.children:
            cost = add_costs(*[cost for cost, _ in compiles])
            if incremental_cost:
                incremental_cost = add_costs(incremental_cost, cost)
            else:
                incremental_cost = cost

    print '# full cost =', full_cost, 'incremental cost =', incremental_cost


@parsable.command
def contrapositves(*filenames):
    '''
    Close rules under contrapositve
    '''
    sequents = []
    for filename in filenames:
        sequents += parser.parse(filename)
    for sequent in sequents:
        print sequent.ascii()
        print
        for neg in sequent.contrapositives():
            print neg.ascii(indent=4)
            print


@parsable.command
def measure(*filenames):
    '''
    Measure complexity of rules in files
    '''
    sequents = []
    for filename in filenames:
        sequents += parser.parse(filename)
    for sequent in sequents:
        measure_sequent(sequent)


@parsable.command
def report(*filenames):
    '''
    Make report.html of rule complexity in files
    '''
    TODO('write sequents to file, coloring by incremental complexity')


@parsable.command
def test_compile(*filenames):
    '''
    Compile rules -> C++
    '''
    for stem_rules in filenames:
        assert stem_rules[-6:] == '.rules', stem_rules
        stem = stem_rules[:6]
        cpp = stem + '.cpp'

        sequents = parser.parse(stem_rules)
        for sequent in sequents:
            for cost, strategy in sequent.compile():
                for line in strategy.cpp_lines():
                    print line
                print

            for event in sequent.get_events():
                for cost, strategy in sequent.compile_given(event):
                    for line in strategy.cpp_lines():
                        print line
                    print


@parsable.command
def compile(*infiles, **kwargs):
    '''
    Compile rules -> C++.
    Optional keyword arguments:
        outfile=OUTFILE
    '''
    outfile = (
            kwargs.get('outfile') or
            '{0}.theory.cpp'.format(infiles[-1].split('.')[0])
            )
    print '# writing', outfile

    sequents = []
    for infile in infiles:
        sequents += parser.parse(infile)

    full_tasks = []
    event_tasks = {}
    for sequent in sequents:
        full_tasks += sequent.compile()
        for event in sequent.get_events():
            tasks = event_tasks.setdefault(event, [])
            tasks += sequent.compile_given(event)

    with open(outfile, 'w') as out:

        def write(line=None):
            if line:
                out.write(line)
            out.write('\n')

        write('// This file was auto generated by pomagma using:')
        write(' '.join(
            ['//', 'python', 'run.py', 'compile'] +
            list(infiles) +
            ['{}={}'.format(key, val) for key, val in kwargs.iteritems()]))
        write()

        write('#include "util.hpp"')
        write('#include "dense_set.hpp"')
        write('#include "nullary_function.hpp"')
        write('#include "unary_function.hpp"')
        write('#include "binary_function.hpp"')
        write('#include "symmetric_function.hpp"')
        write('#include "binary_relation.hpp"')
        write('#include "task_manager.hpp"')
        write()
        write('namespace pomagma {')
        write()

        full_tasks.sort(key=(lambda (cost, _): cost))
        for cost, strategy in full_tasks:
            write()
            write('//' + '-' * 76)
            write('// cost = {0}'.format(cost))
            for line in strategy.cpp_lines():
                write(line)
            write()

        for event, tasks in event_tasks.iteritems():
            tasks.sort(key=(lambda (cost, _): cost))

            write()
            write('//' + '-' * 76)
            write('// TODO given {0}'.format(event))
            for cost, strategy in tasks:
                write()
                write('// cost = {0}'.format(cost))
                for line in strategy.cpp_lines():
                    write(line)
                write()

        write()
        write('} // namespace pomagma')


if __name__ == '__main__':
    parsable.dispatch()
