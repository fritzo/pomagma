import re
import parsable
from textwrap import dedent
from contextlib import contextmanager
from pomagma import parser
from pomagma.compiler import add_costs, get_events, compile_full, compile_given
from pomagma.cpp import Theory


def print_compiles(compiles):
    for cost, strategy in compiles:
        print '# cost = {0}'.format(cost)
        print re.sub(': ', '\n', repr(strategy))
        print


def measure_sequent(sequent):
    print '-' * 78
    print 'Compiling full search: {0}'.format(sequent)
    compiles = compile_full(sequent)
    print_compiles(compiles)
    full_cost = add_costs(*[cost for cost, _ in compiles])

    incremental_cost = None
    for event in get_events(sequent):
        print 'Compiling incremental search given: {0}'.format(event)
        compiles = compile_given(sequent, event)
        print_compiles(compiles)
        if event.args:
            cost = add_costs(*[cost for cost, _ in compiles])
            if incremental_cost:
                incremental_cost = add_costs(incremental_cost, cost)
            else:
                incremental_cost = cost
        else:
            pass  # event is only triggered once, so ignore cost

    print '# full cost =', full_cost, 'incremental cost =', incremental_cost


@parsable.command
def contrapositves(*filenames):
    '''
    Close rules under contrapositve
    '''
    sequents = []
    for filename in filenames:
        sequents += parser.parse(filename)
    for sequent in sequents:
        print sequent.ascii()
        print
        for neg in sequent.contrapositives():
            print neg.ascii(indent=4)
            print


@parsable.command
def measure(*filenames):
    '''
    Measure complexity of rules in files
    '''
    sequents = []
    for filename in filenames:
        sequents += parser.parse(filename)
    for sequent in sequents:
        measure_sequent(sequent)


@parsable.command
def report(*filenames):
    '''
    Make report.html of rule complexity in files
    '''
    TODO('write sequents to file, coloring by incremental complexity')


@parsable.command
def test_compile(*filenames):
    '''
    Compile rules -> C++
    '''
    for stem_rules in filenames:
        assert stem_rules[-6:] == '.rules', stem_rules
        stem = stem_rules[:6]
        cpp = stem + '.cpp'

        sequents = parser.parse(stem_rules)
        for sequent in sequents:
            for cost, strategy in compile_full(sequent):
                print '\n'.join(strategy.cpp_lines())

            for event in get_events(sequent):
                for cost, strategy in compile_given(sequent, event):
                    print '\n'.join(strategy.cpp_lines())


@contextmanager
def line_writer(filename):
    with open(filename, 'w') as out:
        def write(line=None):
            if line:
                out.write(line)
            out.write('\n')
        yield write


@parsable.command
def compile(*infiles, **kwargs):
    '''
    Compile rules -> C++.
    Optional keyword arguments:
        outfile=OUTFILE
    '''
    outfile = (
            kwargs.get('outfile') or
            '{0}.theory.cpp'.format(infiles[-1].split('.')[0])
            )
    print '# writing', outfile
    argstring = ' '.join(
            list(infiles) +
            ['{}={}'.format(key, val) for key, val in kwargs.iteritems()])

    sequents = []
    for infile in infiles:
        sequents += parser.parse(infile)
    theory = Theory(sequents)

    with line_writer(outfile) as write:

        write(dedent('''
        // This file was auto generated by pomagma using:
        // python run.py compile {argstring}

        #include "util.hpp"
        #include "carrier.hpp"
        #include "nullary_function.hpp"
        #include "injective_function.hpp"
        #include "binary_function.hpp"
        #include "symmetric_function.hpp"
        #include "binary_relation.hpp"
        #include "scheduler.hpp"
        #include <atomic>
        #include <vector>
        
        namespace pomagma {{
        ''').format(argstring=argstring))

        write('\n'.join(theory.cpp_lines()))

        write(dedent(
        '''
        } // namespace pomagma
        '''))


if __name__ == '__main__':
    parsable.dispatch()
