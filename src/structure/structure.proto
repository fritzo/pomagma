package pomagma_messaging;

// Example
// A binary function "APP" is represented as a strem of Data messages
// { name:"APP",
//   sparse_function: [
//     { bound: 1,
//       keys: [1, 2, 5],
//       vals: [2, 2, 1]
//     },
//     { bound: 2,
//       keys: [1, 2],
//       vals: [1, 2]
//     }
//   ]
// }

message Algebra {

  message Carrier {
    // carrier data is always dense, ranging in [1, ..., capacity]
    required uint32 capacity = 1;
    repeated uint32 reps = 2 [packed = true];
  }

  message Function {
    enum Arity {
      NULLARY = 1;
      INJECTIVE = 2;
      BINARY = 3;
      SYMMETRIC = 4;
    }

    message DenseData {
      repeated uint32 bound_variables = 1;
      repeated uint32 vals = 2 [packed = true];
    }

    message SparseData {
      repeated uint32 bound_variables = 1;
      // two parallel lists of key,value pairs
      repeated uint32 keys = 2 [packed = true];
      repeated uint32 vals = 3 [packed = true];
    }

    required string name = 1;
    required Arity arity = 2;
  }

  message Relation {
    enum Arity {
      NULLARY = 1;
      UNARY = 2;
      BINARY = 3;
    }

    message DenseData {
      repeated uint32 bound_variables = 1;
      // bits are packed into 64-bit words
      repeated fixed64 words = 2 [packed = true];
    }

    required string name = 1;
    required Arity arity = 2;
  }

  message Signature {
    required Carrier carrier = 1;
    repeated Function functions = 2;
    repeated Relation relations = 3;
  }

  message Data {
    required string name = 1;
    optional Function.DenseData dense_function = 2;
    optional Function.SparseData sparse_function = 3;
    optional Relation.DenseData dense_relation = 4;
  }
}
