#include "conjecture_equal.hpp"
#include "hypothesize.hpp"
#include <pomagma/atlas/macro/carrier.hpp>
#include <pomagma/atlas/macro/binary_relation.hpp>
#include <pomagma/atlas/macro/router.hpp>
#include <pomagma/language/language.hpp>
#include <algorithm>

namespace pomagma
{

namespace detail
{

std::vector<std::pair<Ob, Ob>> conjecture_equal (
        Structure & structure,
        const std::vector<float> & probs,
        const std::vector<std::string> & routes,
        const char * conjectures_file,
        size_t max_count)
{
    POMAGMA_INFO("Conjecturing " << max_count << " equations");
    const Carrier & carrier = structure.carrier();
    const BinaryRelation & NLESS = structure.binary_relation("NLESS");

    POMAGMA_DEBUG("collecting conjectures");
    std::vector<std::pair<Ob, Ob>> conjectures;
    for (auto iter = carrier.iter(); iter.ok(); iter.next()) {
        Ob lhs = * iter;
        for (auto iter = carrier.iter(); iter.ok(); iter.next()) {
            Ob rhs = * iter;
            if (rhs >= lhs) { break; }
            if (NLESS.find_Lx(lhs, rhs)) { continue; }
            if (NLESS.find_Rx(rhs, lhs)) { continue; }
            conjectures.push_back(std::make_pair(lhs, rhs));
        }
    }

    POMAGMA_DEBUG("sorting conjectures");
    max_count = std::min(max_count, conjectures.size());
    auto sort_by_prob = [&](
            const std::pair<Ob, Ob> & x,
            const std::pair<Ob, Ob> & y)
    {
        return probs[x.first] * probs[x.second]
             > probs[y.first] * probs[y.second];
    };
    if (conjectures.size() > max_count) {
        std::nth_element(
                conjectures.begin(),
                conjectures.begin() + max_count,
                conjectures.end(),
                sort_by_prob);
        conjectures.resize(max_count);
    }
    std::sort(conjectures.begin(), conjectures.end(), sort_by_prob);

    POMAGMA_DEBUG("writing conjectures to " << conjectures_file);
    std::ofstream file(conjectures_file, std::ios::out | std::ios::trunc);
    POMAGMA_ASSERT(file, "failed to open " << conjectures_file);
    file << "# equality conjectures generated by pomagma\n";
    for (auto pair : conjectures) {
        const auto & lhs = routes[pair.first];
        const auto & rhs = routes[pair.second];
        file << "EQUAL " << lhs << " " << rhs << "\n";
    }

    return conjectures;
}

void try_prove_nless (
        Structure & structure,
        const std::unordered_map<std::string, float> & language,
        const std::vector<std::string> & routes,
        const std::vector<std::pair<Ob, Ob>> & conjectures,
        const char * conjectures_file,
        const char * theorems_file)
{
    POMAGMA_INFO("Trying to prove inequality theorems");
    const BinaryRelation & LESS = structure.binary_relation("LESS");

    std::vector<std::pair<float, std::string>> filtered_conjectures;
    std::vector<std::string> theorems;
    for (auto pair : conjectures) {
        const Ob lhs = pair.first;
        const Ob rhs = pair.second;
        std::string equation = "EQUAL " + routes[lhs] + " " + routes[rhs];
        POMAGMA_INFO("Hypothesizing " << equation);
        float entropy = hypothesize_entropy(structure, language, pair);
        bool consistent = (entropy > 0);
        if (consistent) {
            filtered_conjectures.push_back(std::make_pair(entropy, equation));
        } else {
            if (LESS.find(lhs, rhs)) {
                std::string nless = "NLESS " + routes[rhs] + " " + routes[lhs];
                theorems.push_back(nless);
            } else if (LESS.find(rhs, lhs)) {
                std::string nless = "NLESS " + routes[lhs] + " " + routes[rhs];
                theorems.push_back(nless);
            }
        }
    }
    std::sort(filtered_conjectures.begin(), filtered_conjectures.end());

    {
        std::ofstream file(conjectures_file, std::ios::out | std::ios::trunc);
        POMAGMA_ASSERT(file, "failed to open " << conjectures_file);
        POMAGMA_DEBUG("writing " << filtered_conjectures.size() <<
                " conjectures to " << conjectures_file);
        file << "# equality conjectures filtered by pomagma\n";
        for (const auto & pair : filtered_conjectures) {
            const auto & equation = pair.second;
            file << equation << "\n";
        }
    }
    {
        POMAGMA_DEBUG("writing " << theorems.size() << " theorems to " <<
            theorems_file);
        std::ofstream file(theorems_file, std::ios::out | std::ios::app);
        POMAGMA_ASSERT(file, "failed to open " << theorems_file);
        file << "# nless theorems proved by pomagma\n";
        for (const auto & theorem : theorems) {
            file << theorem << "\n";
        }
    }
}

} // namespace detail

size_t conjecture_equal (
        Structure & structure,
        const char * language_file,
        const char * conjectures_file,
        size_t max_count)
{
    std::vector<float> probs;
    std::vector<std::string> routes;
    {
        const auto language = load_language(language_file);
        Router router(structure.signature(), language);
        probs = router.measure_probs();
        routes = router.find_routes();
    }

    return conjecture_equal(
            structure,
            probs,
            routes,
            conjectures_file,
            max_count);
}

size_t conjecture_equal (
        Structure & structure,
        const std::vector<float> & probs,
        const std::vector<std::string> & routes,
        const char * conjectures_file,
        size_t max_count)
{
    auto conjectures = detail::conjecture_equal(
        structure,
        probs,
        routes,
        conjectures_file,
        max_count);

    return conjectures.size();
}

void try_prove_nless (
        Structure & structure,
        const char * language_file,
        const char * conjectures_in_file,
        const char * conjectures_out_file,
        const char * theorems_file,
        size_t max_count)
{
    std::vector<float> probs;
    std::vector<std::string> routes;
    auto language = load_language(language_file);
    {
        Router router(structure.signature(), language);
        probs = router.measure_probs();
        routes = router.find_routes();
    }

    const auto conjectures = detail::conjecture_equal(
        structure,
        probs,
        routes,
        conjectures_in_file,
        max_count);

    detail::try_prove_nless(
        structure,
        language,
        routes,
        conjectures,
        conjectures_out_file,
        theorems_file);
}

} // namespace pomagma
