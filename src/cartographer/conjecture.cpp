#include "conjecture.hpp"
#include "carrier.hpp"
#include "binary_relation.hpp"
#include "compact.hpp"
#include "scheduler.hpp"
#include "router.hpp"
#include <pomagma/util/language.hpp>
#include <algorithm>
#include <cstdlib>
#include <unistd.h> // for fork
#include <sys/wait.h> // for wait

namespace pomagma
{

namespace detail
{

std::vector<std::pair<Ob, Ob>> conjecture (
        Structure & structure,
        const std::vector<float> & probs,
        const std::vector<std::string> & routes,
        const char * conjectures_file,
        size_t max_count)
{
    POMAGMA_INFO("Conjecturing " << max_count << " equations");
    auto & signature = structure.signature();
    const Carrier & carrier = structure.carrier();
    const BinaryRelation & nless = * signature.binary_relations("NLESS");

    POMAGMA_DEBUG("collecting conjectures");
    std::vector<std::pair<Ob, Ob>> conjectures;
    for (auto iter = carrier.iter(); iter.ok(); iter.next()) {
        Ob lhs = * iter;
        for (auto iter = carrier.iter(); iter.ok(); iter.next()) {
            Ob rhs = * iter;
            if (rhs >= lhs) { break; }
            if (nless.find_Lx(lhs, rhs)) { continue; }
            if (nless.find_Rx(rhs, lhs)) { continue; }
            conjectures.push_back(std::make_pair(lhs, rhs));
        }
    }

    POMAGMA_DEBUG("sorting conjectures");
    max_count = std::min(max_count, conjectures.size());
    auto sort_by_prob = [&](
            const std::pair<Ob, Ob> & x,
            const std::pair<Ob, Ob> & y)
    {
        return probs[x.first] * probs[x.second]
             > probs[y.first] * probs[y.second];
    };

    std::nth_element(
            conjectures.begin(),
            conjectures.begin() + max_count,
            conjectures.end(),
            sort_by_prob);
    conjectures.resize(max_count);
    std::sort(conjectures.begin(), conjectures.end(), sort_by_prob);

    POMAGMA_DEBUG("writing conjectures to " << conjectures_file);
    std::ofstream file(conjectures_file, std::ios::out);
    POMAGMA_ASSERT(file, "failed to open " << conjectures_file);
    file << "# conjectures generated by pomagma";
    for (auto pair : conjectures) {
        const auto & lhs = routes[pair.first];
        const auto & rhs = routes[pair.second];
        file << "\nEQUAL " << lhs << " " << rhs;
    }

    return conjectures;
}

inline float get_entropy (const std::vector<float> & probs)
{
    float entropy = 0;
    for (float p : probs) {
        if (p > 0) {
            entropy += p * logf(p);
        }
    }
    return entropy;
}

void weigh_conjecture (
        Structure & structure,
        const std::unordered_map<std::string, float> & language,
        Ob lhs,
        Ob rhs,
        const std::string & equation,
        const char * conjectures_file)
{
    pid_t child = fork();
    POMAGMA_ASSERT(child != -1, "fork failed");

    if (child == 0) {
        POMAGMA_INFO("Assuming " << equation);
        Carrier & carrier = structure.carrier();
        carrier.set_merge_callback(schedule_merge);
        Ob dep = std::max(lhs, rhs);
        Ob rep = std::min(lhs, rhs);
        carrier.merge(dep, rep);
        process_mergers(structure.signature());
        size_t nullary_count = structure.signature().nullary_functions().size();
        bool consistent = carrier.item_count() >= nullary_count;
        if (consistent) {
            compact(structure);

            POMAGMA_DEBUG("measuring entropy");
            Router router(structure, language);
            const std::vector<float> probs = router.measure_probs(0.01f);
            float entropy = get_entropy(probs);
            std::ofstream file(conjectures_file, std::ios::app);
            POMAGMA_ASSERT(file, "failed to open " << conjectures_file);
            file << "\n" << entropy << " " << equation;
        }
        _exit(0);
    } else {
        int status;
        wait(&status);
        POMAGMA_ASSERT(status == 0, "child process failed");
    }
}

void conjecture_deep (
        Structure & structure,
        const std::unordered_map<std::string, float> & language,
        const std::vector<std::string> & routes,
        const std::vector<std::pair<Ob, Ob>> & shallow_conjectures,
        const char * conjectures_file)
{
    POMAGMA_INFO("Generating deep conjectures");
    // TODO omit binary relations
    //structure.signature().binary_relations().clear();

    POMAGMA_DEBUG("writing conjectures to " << conjectures_file);
    {
        std::ofstream file(conjectures_file, std::ios::out);
        POMAGMA_ASSERT(file, "failed to open " << conjectures_file);
        file << "# deep conjectures generated by pomagma";
    }
    for (auto pair : shallow_conjectures) {
        const Ob lhs = pair.first;
        const Ob rhs = pair.second;
        std::string equation = "EQUAL " + routes[lhs] + " " + routes[rhs];
        weigh_conjecture(
            structure,
            language,
            lhs,
            rhs,
            equation,
            conjectures_file);
    }
}

} // namespace detail

void conjecture_shallow (
        Structure & structure,
        const char * language_file,
        const char * conjectures_file,
        size_t max_count)
{
    const auto language = load_language(language_file);
    Router router(structure, language);
    const std::vector<float> probs = router.measure_probs();
    std::vector<std::string> routes = router.find_routes();
    detail::conjecture(structure, probs, routes, conjectures_file, max_count);
}

void conjecture_deep (
        Structure & structure,
        const char * language_file,
        const char * conjectures_file,
        size_t max_count)
{
    const auto language = load_language(language_file);
    Router router(structure, language);
    const std::vector<float> probs = router.measure_probs();
    std::vector<std::string> routes = router.find_routes();
    const auto conjectures = detail::conjecture(
        structure,
        probs,
        routes,
        conjectures_file,
        max_count);
    detail::conjecture_deep(
        structure,
        language,
        routes,
        conjectures,
        conjectures_file);
}

} // namespace pomagma
