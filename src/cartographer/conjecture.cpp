#include "conjecture.hpp"
#include "carrier.hpp"
#include "binary_relation.hpp"
#include "router.hpp"
#include "hypothesize.hpp"
#include <pomagma/util/language.hpp>
#include <algorithm>

namespace pomagma
{

namespace detail
{

std::vector<std::pair<Ob, Ob>> conjecture (
        Structure & structure,
        const std::vector<float> & probs,
        const std::vector<std::string> & routes,
        const char * conjectures_file,
        size_t max_count)
{
    POMAGMA_INFO("Conjecturing " << max_count << " equations");
    auto & signature = structure.signature();
    const Carrier & carrier = structure.carrier();
    const BinaryRelation & nless = * signature.binary_relations("NLESS");

    POMAGMA_DEBUG("collecting conjectures");
    std::vector<std::pair<Ob, Ob>> conjectures;
    for (auto iter = carrier.iter(); iter.ok(); iter.next()) {
        Ob lhs = * iter;
        for (auto iter = carrier.iter(); iter.ok(); iter.next()) {
            Ob rhs = * iter;
            if (rhs >= lhs) { break; }
            if (nless.find_Lx(lhs, rhs)) { continue; }
            if (nless.find_Rx(rhs, lhs)) { continue; }
            conjectures.push_back(std::make_pair(lhs, rhs));
        }
    }

    POMAGMA_DEBUG("sorting conjectures");
    max_count = std::min(max_count, conjectures.size());
    auto sort_by_prob = [&](
            const std::pair<Ob, Ob> & x,
            const std::pair<Ob, Ob> & y)
    {
        return probs[x.first] * probs[x.second]
             > probs[y.first] * probs[y.second];
    };

    std::nth_element(
            conjectures.begin(),
            conjectures.begin() + max_count,
            conjectures.end(),
            sort_by_prob);
    conjectures.resize(max_count);
    std::sort(conjectures.begin(), conjectures.end(), sort_by_prob);

    POMAGMA_DEBUG("writing conjectures to " << conjectures_file);
    std::ofstream file(conjectures_file, std::ios::out | std::ios::trunc);
    POMAGMA_ASSERT(file, "failed to open " << conjectures_file);
    file << "# shallow conjectures generated by pomagma";
    for (auto pair : conjectures) {
        const auto & lhs = routes[pair.first];
        const auto & rhs = routes[pair.second];
        file << "\nEQUAL " << lhs << " " << rhs;
    }

    return conjectures;
}

void conjecture_deep (
        Structure & structure,
        const std::unordered_map<std::string, float> & language,
        const std::vector<std::string> & routes,
        const std::vector<std::pair<Ob, Ob>> & shallow_conjectures,
        const char * conjectures_file)
{
    POMAGMA_INFO("Generating deep conjectures");
    std::vector<std::pair<float, std::string>> deep_conjectures;
    for (auto pair : shallow_conjectures) {
        const Ob lhs = pair.first;
        const Ob rhs = pair.second;
        std::string equation = "EQUAL " + routes[lhs] + " " + routes[rhs];
        POMAGMA_INFO("Hypothesizing " << equation);
        float entropy = hypothesize_entropy(structure, language, pair);
        bool consistent = (entropy > 0);
        if (consistent) {
            deep_conjectures.push_back(std::make_pair(entropy, equation));
        }
    }
    std::sort(deep_conjectures.begin(), deep_conjectures.end());

    POMAGMA_DEBUG("writing conjectures to " << conjectures_file);
    std::ofstream file(conjectures_file, std::ios::out | std::ios::trunc);
    POMAGMA_ASSERT(file, "failed to open " << conjectures_file);
    file << "# deep conjectures generated by pomagma";
    for (const auto & pair : deep_conjectures) {
        const auto & equation = pair.second;
        file << "\n" << equation;
    }
}

} // namespace detail

void conjecture_shallow (
        Structure & structure,
        const char * language_file,
        const char * conjectures_file,
        size_t max_count)
{
    const auto language = load_language(language_file);
    Router router(structure, language);
    const std::vector<float> probs = router.measure_probs();
    std::vector<std::string> routes = router.find_routes();
    detail::conjecture(structure, probs, routes, conjectures_file, max_count);
}

void conjecture_deep (
        Structure & structure,
        const char * language_file,
        const char * conjectures_file,
        size_t max_count)
{
    const auto language = load_language(language_file);
    Router router(structure, language);
    const std::vector<float> probs = router.measure_probs();
    std::vector<std::string> routes = router.find_routes();
    const auto conjectures = detail::conjecture(
        structure,
        probs,
        routes,
        conjectures_file,
        max_count);
    detail::conjecture_deep(
        structure,
        language,
        routes,
        conjectures,
        conjectures_file);
}

} // namespace pomagma
